Тех задание для приложения с парсингом читаемых данных и сохранением обработанных данных в таблицу или выводом таблиц на экран консоли.

необходимо на пайтон создать небольшой проект парсер данных из табличных документов pdf или docx с последующим вычислением итогового значения для найденного в таблице месяца и сохранением данных в БД для каждого пользователя по годам.

1. Работа с исходными данными на диске.
а) Поочередное чтение документов (можно будет указать как аргументом в командной строке или в указанной папке с полным или относительным путем или по умолчанию читать из определенной папки в настройках).
б) Поиск в каждом документе (это доп соглашение к договору для понимания содержания файла) покупателя или покупателей:
- названия находятся в блоке, который всегда начинается с фразы в кавычках: "Публичное акционерное общество"   и заканчивается там где начинается первый пункт соглашения (пример: 1.) Можно определить как конфигурационные настройки в отдельном файле. (Дальше будут и другие переменные в настройках).
- из этого блока надо вытащить названия покупателя или покупателей. Названия идут всегда с указания формы юр.лица или индивидуального предпринимателя, которые могут быть прописаны полностью, так и сокращенно, типа ПАО, ИП и тд (тоже вынести в настройки), а заканчиваются или кавычкой (спецсимвол, кавычки могут быть разными) или точкой или запятой (например: ... и ИП  Бучнев Алексей Александрович, именуемый в дальнейшем «Покупатель 1»)
- найденный список покупателей хранить в порядке их обнаружения. так как потом его надо будет использовать для сопоставления связанной таблицы со своим покупателем в рамках одного соглашения.
- далее находим таблицы в блоке между пунктом 2 и 3 и достаем эти данные.
- найденные таблицы присваиваем найденным выше покупателям. Необходимо учесть такую особенность: если в документе найдено больше названий покупателей чем количество таблиц, то всегда сопоставляем покупателя и таблицы по индексу, начиная с последнего и все оставшиеся покупатели без таблиц должны быть объединены с первым покупателем.
- структура таблиц может отличаться. Необходимо забирать данные из первой колонки (это дата в виде: мес/год или просто месяц. если год не указан, то будем сохранять текущий. пример даты: Март 2025 или МАРТ или март 25 или МАРТ, 2025 или 03.2025 или 03/2025 или мар.25 или Март 2025г. и тд). Нам нужно сохранять дату в своем унифицированном виде. все строки, которые не соответствуют формату нашей даты из первой колонки - игнорировать.
- даты могут начинаться с пред года и заканчиваться текущим. Здесь для сохранения данных из строк таблицы надо применять фильтр по году, который задается как аргумент в командной строке или по умолчанию берется текущий год. список данных полученных строк должен быть отсортирован в последующем по месяцу.
- следующие колонки за датой (2..N) - это вид продукции, в которых указаны объемы в тоннах в виде чисел с запятой или точкой как разделитель. нам необходимо всегда складывать значения в этих колонках и сохранять в массив данных вместе с датой. крайняя правая колонка иногда может оказаться итоговой и там уже будут сложены все колонки. Тогда надо выявить это и не брать ее данные для суммирования. можно применить алгоритм сравнения всех сложенных данных с данными крайней колонки и при совпадении не брать эту колонку в расчет.
- при вытаскивании данных из таблиц надо проверять: если не хватает суммированных данных за какой-то месяц, то создать отсутствующую дату с нулевым значением продукции.
- далее находим допустимое отклонение в виде абсолютного числа (в тоннах) или процента. Число надо искать в блоке текста, который начинается с пункта 4 и до пункта 5. Отклонения принято считать как +/-. Это значит, что если найдется в блоке более одного числа, то берем всегда меньшее, то есть последнее. Если найдешь число в виде процента, то его надо сохранить в свою переменную, а абсолютное значение - в свою, и добавить к данным таблиц, которые мы выше получили. Если таблиц в одном документе более одной, то сохраняем одинаковый показатель отклонения для всех таблиц в пределах одного документа.
в) Сохранение даннных в таблицы:
- уникального пользователя добавлять в таблицу Customer;
- данные с полученными объемами из таблиц для каждого покупателя (или группы покупателей) сохранить в своей таблице (поля: год, 12 суммированных показателей для каждого месяца и поле с отклонением для хранения в виде строки или процента или числа с запятой). Таблицы связать между собой, так как у покупателя будут новые данные по годам. Учесть что если несколько покупателей претендуют на одну таблицу с данными, то такого покупателя так и записывать в БД под одним названием через '/'

2) после накопления всех данных для найденных покупателей, необходимо экспортировать их в xlsx файл
- колонки: название | итоговые значения продукции с 1 по 12 месяц | допустимое отклонение в % | допустимое отклонение (число)
- название результирующего документа указать или в командной строке как аргумент, или по умолчанию взять из файла настроек.

предусмотреть в проекте:
- несуществующие файлы пропускать без ошибки
-  если папки при создании документа не существовали, то создавать.
- если при сохранении документ уже был, то предложить перезаписать или создать новый с добавлением индекса (-01, 02 и тд). можно в настройках предусмотреть переменную для автосохранения с новым именем
- предусмотреть работу с cli через определенную команду с аргументами
- подробно составить описание аргументов для запуска через командную строку для --help
- предусмотреть опцию в командной строке для вывода в консоль в отформатированном цветном виде с использованием соответствующих популярных библиотек
- в настройках предусмотреть переменную для ограничения максимального количества читаемых файлов с диска
- в настройках добавить переменную отображения обработанных данных списком в количестве N при выводе в консоль.
- при запуске приложения через cli с аргументом вывода в консоль и без перечисления читаемых файлов, выводить на экран данные всегда порциями по N строк (использовать переменную из настроек. если не определена, то например 10). после нажатия на пробел продолжить работу приложения с поcледующим чтением найденных файлов на диске и выводом обработанных данных. Прервать работу можно по спец комбинации нажатых клавиш (обычно ctrl-C)
- приложение должно быть удобным для работы обычному пользователю как прямым запуском через пайтон, так и из консоли с простой командой запуска и интуитивно понятными аргументами и опциями
- код должен быть удобно структурированным и иметь понятную архитектуру с разделением ответственности
- в коде предусмотреть аннотацию функций и классов, к неочевидным блокам добавлять на русском комментарии, чтобы можно было другим разобраться в коде в будущем.
- не перегружать файлы логикой и делить их при большой вложенности.
- использовать максимально regex, которые можно выносить всегда  в переменные для удобства чтения. предусматривать, что текст котопый надо парсить, составляли обычные люди и могли вставлять лишние пробелы или использовать разные виды кавычек
- предусмотреть защиту от некорректного парсинга, с добавлением к данным отметки об исключении. например, предположить, что название покупателя не может быть более 100 символов и такие данные отмечать в массиве ошибок. Такой подход предусмотреть для парсинга числа из допустимого отклонения и всех данных из таблиц. если не смог распарсить дату из первой колонки, то  предполагай, что номер строки, в которых последующие колонки сложились в число, это индекс месяца, а год будет текущим. Для такой валидации предусмотри возможность добавлять в начало соответствующей ячейки специальный цветной символ '*' ,  чтобы пометить как некорректно считанное значение. Если не смог распарсить дату, то добавь спец символ к значению из заголовка.
- придерживайся правила создания набора утилит, которые должны быть более независимыми от сторонних библиотек и более изолированными, чтобы удобно было их протестировать при желании.
- создай README с удобным описанием и перечнем команд для установки, включая запуск из консоли
- допустимые библиотеки:
pydantic
sqlmodel
python-docx
openpyxl
PyPDF2
typer
pytest
